;; Analyzed by ClojureScript 0.0-2674
{:defs {main {:protocol-inline nil, :name client/main, :variadic false, :file "src/client.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core.async.impl.channels/ManyToManyChannel, :variadic false, :max-fixed-arity 0}), :line 70, :end-line 70, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Application entry point", :test true}, init-updates {:protocol-inline nil, :name client/init-updates, :variadic false, :file "src/client.cljs", :end-column 20, :method-params ([app]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj-nil, :variadic false, :max-fixed-arity 1}), :line 57, :end-line 57, :max-fixed-arity 1, :fn-var true, :arglists (quote ([app])), :doc "For every entry in a map of channel identifiers to consumers,\n  initiate a channel listener which will update the application state\n  using the appropriate function whenever a value is recieved, as\n  well as triggering a render.", :test true}, load-app {:protocol-inline nil, :name client/load-app, :variadic false, :file "src/client.cljs", :end-column 16, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IMap, :variadic false, :max-fixed-arity 0}), :line 45, :end-line 45, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Return a map containing the initial application", :test true}, handle-response {:protocol-inline nil, :name client/handle-response, :variadic false, :file "src/client.cljs", :end-column 23, :method-params ([app p__35338]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 42, :end-line 42, :max-fixed-arity 2, :fn-var true, :arglists (quote ([app {:keys [status body], :as resp}])), :test true}, init-history {:protocol-inline nil, :name client/init-history, :variadic false, :file "src/client.cljs", :end-column 20, :method-params ([app]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 30, :end-line 30, :max-fixed-arity 1, :fn-var true, :arglists (quote ([app])), :doc "Set up Google Closure history management", :test true}, get-list {:protocol-inline nil, :name client/get-list, :variadic false, :file "src/client.cljs", :end-column 16, :method-params ([app kw]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core.async.impl.channels/ManyToManyChannel, :variadic false, :max-fixed-arity 2}), :line 22, :end-line 22, :max-fixed-arity 2, :fn-var true, :arglists (quote ([app kw])), :test true}, get-some {:protocol-inline nil, :name client/get-some, :variadic false, :file "src/client.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core.async.impl.channels/ManyToManyChannel, :variadic false, :max-fixed-arity 1}), :line 16, :end-line 16, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :test true}}, :name client, :doc nil, :excludes #{}, :use-macros {go cljs.core.async.macros}, :require-macros {cljs.core.async.macros cljs.core.async.macros}, :uses {<! cljs.core.async, chan cljs.core.async, >! cljs.core.async, read-string cljs.reader}, :requires {clojure.browser.repl clojure.browser.repl, cljs-http.client cljs-http.client, goog.History goog.History, cljs.core.async cljs.core.async, e goog.events, render render, cljs.reader cljs.reader, repl clojure.browser.repl, goog.events goog.events, http cljs-http.client}, :imports nil}